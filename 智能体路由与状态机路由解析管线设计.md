# 智能体路由、状态机路由与解析-抽取管线详细设计说明

## A. 智能体路由（Agent Router）

### 职责边界
- 意图分发、工具/模型选择、上下文拼装（仅引用型可见数据）
- 负责用户意图识别与智能体分发，上下文聚合与决策
- 作为路由与编排层的核心组件，连接接入层与解析层

### 输入语义事件
- UserUtterance：用户发言或行为输入
- NPCHeartbeat：NPC心跳事件，定期触发状态检查
- SystemTick：系统时钟事件，用于定时任务触发
- TimeNodeTrigger：时间节点触发事件，用于剧情推进
- OutOfBandMessage：带外消息，系统级通知或干预

### 决策流程
1. 故事内/外初判：基于内容特征判断输入属于故事内还是故事外
2. 并行触发[信息分类与拆分、实体发掘]：同时启动解析与抽取管线的两个核心模块
3. 感知裁剪：根据角色感知范围过滤可见信息
4. 记忆注入：从记忆索引中提取相关历史信息
5. 工具/模型选择：基于规则和置信度选择合适的处理工具
6. 输出执行意图：生成最终的路由决策和执行建议

### 上下文构建
- 视域裁剪：按角色感知范围分层过滤信息
- 记忆时间窗裁剪：根据时间相关性筛选历史记忆
- 最小必要引用：仅包含必要的上下文引用，避免数据冗余
- 隐私剔除：严格过滤敏感信息和越权数据
- 空间裁剪：基于射程/范围/遮挡规则进行空间可见性计算

### 工具/模型选择
- 规则优先→LLM补全：确定性规则优先，不确定性场景使用LLM
- 不确定性阈值与信心度门槛：设置明确的置信度阈值
- 固定种子与可重放：测试环境使用固定种子保证可重放性
- 混合策略可配置权重：规则与LLM的权重可动态调整

### 输出语义事件
- ParsedIntent：解析后的意图结构化表示
- ActionProposal：基于意图生成的行动建议
- ContextAssembled：组装完成的上下文信息
- RoutingDecision：最终的路由决策结果
- RoutingError：路由过程中的错误信息

### 并发与事务
- 按会话/场景分片：保证同一会话内的有序处理
- 近似恰好一次：幂等键=会话ID+消息序列号
- 失败重试与规则降级：失败时自动重试，多次失败后降级为规则处理
- 跨模块消息至少一次语义：关键链路实现幂等去重

### 失败与降级
- 缓存回退：路由失败时使用缓存的历史决策
- 模板响应：极端情况下使用预设模板响应
- 骰子接入点记录触发原因：记录随机介入的触发点和原因
- 越权/污染拦截：严格检测和阻止越权访问和数据污染

### SLO与可观测性
- 路由≤150ms：单次路由决策的延迟预算
- 记录决策路径：完整记录路由决策的每一步选择
- 所用规则/模型：记录使用的具体规则和模型版本
- 裁剪摘要：记录上下文裁剪的统计信息
- 信心度与随机种子：记录决策置信度和使用的随机种子

## B. 状态机路由（State Machine Router）

### 顶层状态
- StoryOutside：故事外状态，用于元游戏交互
- StoryInside：故事内状态，正常游戏进行
- ResolvingAction：行动解析状态，处理具体行为
- TimeAdvancing：时间推进状态，处理时间流逝
- Paused：暂停状态，游戏暂停或中断
- NarrationPending：待叙述状态，等待叙事内容生成
- OutOfBandDiscussion：带外讨论状态，系统级对话

### 事件矩阵
| 触发事件 | 状态迁移 | 守卫条件 | 副作用 |
|---------|---------|---------|--------|
| UserUtterance | StoryOutside→StoryInside | 故事内内容检测 | 时间推进、记忆标注 |
| ActionRequest | StoryInside→ResolvingAction | 行动有效性验证 | 空间刷新、通知执行层 |
| TimeNodeTrigger | StoryInside→TimeAdvancing | 时间条件满足 | 时间轴推进、状态更新 |
| PauseRequest | 任何状态→Paused | 权限验证 | 状态保存、通知暂停 |
| SystemError | 任何状态→StoryOutside | 错误级别判断 | 错误记录、状态重置 |

### 冲突仲裁
- 时间优先级 + 事件时间戳：基于时间戳和优先级解决冲突
- 长事务/延迟行动建模：支持需要长时间处理的复杂行动
- 回滚与重放规则：状态冲突时支持回滚和事件重放
- 优先级调度避免饥饿：确保低优先级事件也能得到处理

### 记忆定位
- 每次迁移生成记忆锚点：包含valid_time、record_time、source_event
- 支持事件区间引用：可以引用一段时间内的事件集合
- 时间轴索引：基于时间轴快速定位相关记忆
- 记忆版本管理：支持记忆的多版本管理和追溯

### 空间联动
- 进入ResolvingAction前做空间可达性/遮挡校验
- 失败则回退或骰子介入：空间校验失败时的处理策略
- 空间状态缓存：缓存空间计算结果提高性能
- 空间事件传播：空间变更事件的传播机制

### 并发与一致性
- 按会话/场景独立状态机：不同会话的状态机独立运行
- 关键迁移强一致：事务边界=迁移日志+事件持久化
- 其他最终一致：非关键状态变更允许最终一致
- 状态快照：定期生成状态快照支持快速恢复

### 输出语义事件
- StateTransitionStarted：状态转换开始事件
- StateTransitionCommitted：状态转换提交事件
- TimelineAdvanced：时间轴推进事件
- MemoryAnchored：记忆锚点生成事件
- SpatialValidated：空间校验完成事件
- TransitionRejected：状态转换拒绝事件

### SLO与可观测性
- 单次迁移≤100ms：状态转换的延迟预算
- 审计全量：所有状态转换都需要审计记录
- 时间线可重建：支持基于事件重建完整时间线
- 状态一致性监控：实时监控状态一致性指标

## C. 解析与抽取管线（Parsing & Extraction Pipeline）

### 阶段清单（串并行混合）
1. 归一化：文本标准化和预处理
2. 语言检测：识别输入语言类型
3. 切分：将长文本分割为可处理的片段
4. 信息分类：区分行为/发言/心理/场外内容
5. 行动语义映射：将自然语言映射为结构化行动
6. NER/别名消歧：命名实体识别和别名消解
7. 关系抽取：识别实体间的关系
8. 图检索对齐：与图数据库中的实体对齐
9. 置信度评估：评估解析结果的置信度
10. 产出结构化结果：生成最终的结构化输出

### 规则/LLM混合
- 规则覆盖确定性：确定性场景使用规则处理
- LLM仅在低置信度或复杂语义时启用：LLM作为补充
- 可配置权重：规则与LLM的权重可动态配置
- 决策记录可重放：所有决策过程记录支持重放

### 实体与关系
- 全局稳定ID：为每个实体分配全局唯一稳定标识
- 图数据库检索去重：通过图检索避免重复实体
- 别名表与上下文别名合并：维护别名映射表
- 空间实体带位置/拓扑引用：空间实体包含位置和拓扑信息

### 空间裁剪
- 按距离/范围/施法模板：基于距离和范围规则过滤
- 视线/弹道遮挡：计算视线和弹道遮挡
- 声光传播近似：模拟声音和光的传播
- 产出"可见实体清单"供上下文组装

### 时间与记忆
- 解析输出绑定事件时间：所有解析结果绑定时间信息
- 生成记忆引用：生成事件ID/区间引用
- 支持历史线索回溯：支持基于时间的历史回溯
- 污染隔离缓存：隔离可能被污染的缓存数据

### 输出语义事件
- MessageNormalized：消息标准化完成事件
- Segmented：文本切分完成事件
- Classified：信息分类完成事件
- EntitiesResolved：实体解析完成事件
- RelationsResolved：关系解析完成事件
- SpatialVisibilityComputed：空间可见性计算完成事件
- ParsedActionReady：解析行动准备就绪事件

### 并发与幂等
- 按消息幂等键：会话ID+序号+内容哈希
- 阶段结果可缓存：TTL与版本控制
- 失败重试与阶段性短路：支持阶段级重试和短路
- 并行处理优化：可并行阶段同时执行

### 随机与降级
- 当解析冲突/信息不足，触发骰子或模板提示
- 记录触发点与替代路径：记录随机介入的详细情况
- 多级降级策略：从LLM到规则再到模板的多级降级
- 降级决策审计：记录所有降级决策的依据

### SLO与可观测性
- 总耗时≤600ms：规则≤200ms、检索≤150ms、LLM≤250ms预算
- 全链路指标：记录每个阶段的性能指标
- 抽取对齐率：监控抽取结果与图数据库的对齐率
- 错误分布分析：分析各类错误的发生频率

## 接口语义与事件命名规范

### 事件命名
- 动词过去式 + 语义名：如EntitiesResolved、ContextAssembled、StateTransitionCommitted
- 统一命名模式：所有事件遵循统一的命名模式
- 语义明确性：事件名称应清晰表达其含义

### 幂等键与去重
- 事件携带业务ID/序号/哈希：确保事件的唯一性
- 跨模块至少一次：模块间通信保证至少一次语义
- 关键链路近似恰好一次：关键业务链路实现幂等去重
- 去重策略：基于业务ID和时间窗口的去重策略

### 引用型上下文
- 仅ID与必要片段引用：避免大块文本复制
- 禁止复制大块文本：减少数据传输和存储开销
- 标签含可见性与版本态：上下文标签包含可见性和版本信息

## 规则/LLM/骰子的协同与阈值

### 完备度—随机度曲线
- 默认反比：完备度越高随机度越低
- 可配置拐点与上限：支持自定义曲线参数
- 每次决定入审计：所有决策过程记录审计日志
- 动态调整：根据场景动态调整完备度-随机度关系

### 触发策略
- 低置信/冲突/缺省能力 → LLM：规则无法处理时启用LLM
- LLM仍不足 → 骰子：LLM也无法处理时使用随机决策
- 均失败 → 模板降级：所有方法都失败时使用模板响应
- 阈值可配置：各级触发的阈值可动态配置

### 可重放
- 记录规则版本：记录使用的规则版本信息
- 提示与温度/种子：记录LLM的提示词和参数
- 输入摘要与输出哈希：记录输入输出摘要和哈希值
- 完整决策链：记录完整的决策链条

## 空间与时间的校验挂钩

### 前置空间校验
- 进入执行层前强制可达性/遮挡验证
- 失败则返回修正建议或骰子：校验失败时的处理策略
- 空间状态缓存：缓存空间状态提高校验效率
- 校验结果记录：记录所有空间校验的结果

### 时间节点
- 宏观时间推进触发组织/群体行为
- 解析产出更新时间成本：解析结果包含时间成本信息
- 状态机推进时间轴并生成记忆锚点
- 时间一致性保证：确保时间相关操作的一致性

## 并发、事务与错误处理

### 并发模型
- 路由按会话/场景分片：保证同一会话内的有序处理
- 解析按消息并行：不同消息可以并行解析
- 实体检索与空间校验可并行化：提高处理效率
- 资源隔离：不同类型任务的资源隔离

### 事务边界
- 状态迁移+事件持久化为一事务：保证状态一致性
- 解析阶段最终一致：解析过程允许最终一致
- 失败补偿与死信策略明确：定义明确的补偿和死信处理
- 分布式事务支持：支持跨模块的分布式事务

### 安全与越权
- 上下文构建执行感知隔离：严格隔离不同角色的上下文
- 越权即拒绝并审计：检测到越权立即拒绝并记录
- 缓存隔离防污染：不同角色的缓存数据隔离
- 权限动态验证：实时验证操作权限

## SLO与观测最小集

### SLO
- 路由≤150ms：路由决策的延迟预算
- 解析≤600ms：解析管线的延迟预算
- 状态迁移≤100ms：状态迁移的延迟预算
- 合计≤850ms：总延迟预算（不含LLM长尾）
- 超时走降级：超时后自动降级处理

### 观测
- 每阶段计时：记录每个阶段的处理时间
- 命中率（规则/LLM/骰子）：记录各类处理方式的命中率
- 空间/时间校验结果：记录校验结果和统计
- 错误分布：分析各类错误的发生频率和分布
- 回放样本采样率配置：可配置的回放采样率

## 对Neo4j/JSONL的映射指引

### 节点
- Event：解析/路由/迁移事件节点
- Actor：角色实体节点
- Scene：场景实体节点
- Item：物品实体节点
- Organization：组织实体节点
- ActionIntent：行动意图节点
- MemoryAnchor：记忆锚点节点

### 关系
- EMITS：发出关系
- CAUSAL：因果关系
- DERIVES：派生关系
- REFS_VISIBLE：可见性引用
- LOCATED_IN：位置关系
- OCCURS_AT：发生位置
- PERTAINS_TO：归属关系

### 键
- 稳定业务键：使用稳定的业务标识作为主键
- 导入分块：大数据量导入时分块处理
- 去重基于稳定键+版本态：基于稳定键和版本状态去重
- 索引策略：根据查询模式设计索引策略

## 完成条件

三部分均给出：
- 职责：明确定义各组件的职责边界
- 输入输出语义：定义清晰的输入输出语义事件
- 内部阶段：详细描述内部处理阶段
- 阈值与降级：定义处理阈值和降级策略
- 并发/事务：设计并发模型和事务边界
- SLO/观测：定义性能目标和观测指标
- 时间/空间校验与记忆定位：设计时空校验和记忆定位机制

文档为纯文本分点、术语一致、不含字段级定义与代码；可直接指导后续"执行层细化"与"Neo4j JSONL模式定义"。